From 69023e7e4f43de46bacb704d150a8f3d6367752d Mon Sep 17 00:00:00 2001
From: Elias Bakken <elias.bakken@gmail.com>
Date: Thu, 4 Apr 2013 11:22:38 -0500
Subject: [PATCH 157/157] cape: add support for replicape 00A1 and fix the ADC

Signed-off-by: Elias Bakken <elias.bakken@gmail.com>
Signed-off-by: Robert Nelson <robertcnelson@gmail.com>
---
 arch/arm/boot/dts/am335x-bone-common.dtsi   |    8 +
 drivers/iio/adc/ti_am335x_adc.c             |   59 ++++----
 drivers/input/touchscreen/ti_am335x_tsc.c   |   29 ++--
 drivers/mfd/ti_am335x_tscadc.c              |    3 +-
 drivers/pwm/pwm_test.c                      |  117 ++++++++-------
 firmware/Makefile                           |    4 +
 firmware/capes/cape-bone-replicape-00A1.dts |  216 +++++++++++++++++++++++++++
 include/linux/mfd/ti_am335x_tscadc.h        |    2 +
 8 files changed, 338 insertions(+), 100 deletions(-)
 create mode 100644 firmware/capes/cape-bone-replicape-00A1.dts

diff --git a/arch/arm/boot/dts/am335x-bone-common.dtsi b/arch/arm/boot/dts/am335x-bone-common.dtsi
index 4ef3d81..cee3943 100644
--- a/arch/arm/boot/dts/am335x-bone-common.dtsi
+++ b/arch/arm/boot/dts/am335x-bone-common.dtsi
@@ -320,6 +320,14 @@
 					dtbo = "cape-bone-mrf24j40-00A0.dtbo";
 				};
 			};
+			/* Replicape */
+			cape@10 {
+				part-number = "BB-BONE-REPLICAP";
+				version@00A1 {
+					version = "00A1";
+					dtbo = "cape-bone-replicape-00A1.dtbo";
+				};
+			};
 		};
 	};
 
diff --git a/drivers/iio/adc/ti_am335x_adc.c b/drivers/iio/adc/ti_am335x_adc.c
index ee20c0c..f7d6913 100644
--- a/drivers/iio/adc/ti_am335x_adc.c
+++ b/drivers/iio/adc/ti_am335x_adc.c
@@ -26,6 +26,7 @@
 #include <linux/iio/machine.h>
 #include <linux/iio/driver.h>
 #include <linux/regmap.h>
+#include <linux/delay.h>
 
 #include <linux/io.h>
 #include <linux/mfd/ti_am335x_tscadc.h>
@@ -55,8 +56,8 @@ static void tiadc_writel(struct tiadc_device *adc, unsigned int reg,
 
 static void tiadc_step_config(struct tiadc_device *adc_dev)
 {
-	unsigned int stepconfig;
-	int i, channels = 0, steps;
+	unsigned int config;
+	int i, chan;
 
 	/*
 	 * There are 16 configurable steps and 8 analog input
@@ -68,19 +69,15 @@ static void tiadc_step_config(struct tiadc_device *adc_dev)
 	 * needs to be given to ADC to digitalize data.
 	 */
 
-	steps = TOTAL_STEPS - adc_dev->channels;
-	channels = TOTAL_CHANNELS - adc_dev->channels;
+	config = STEPCONFIG_AVG_16 | STEPCONFIG_FIFO1;
 
-	stepconfig = STEPCONFIG_AVG_16 | STEPCONFIG_FIFO1;
-
-	for (i = (steps + 1); i <= TOTAL_STEPS; i++) {
-		tiadc_writel(adc_dev, REG_STEPCONFIG(i),
-				stepconfig | STEPCONFIG_INP(channels));
-		tiadc_writel(adc_dev, REG_STEPDELAY(i),
-				STEPCONFIG_OPENDLY);
-		channels++;
+	chan = TOTAL_CHANNELS-1;
+	for (i = TOTAL_STEPS; i > TOTAL_STEPS-adc_dev->channels; i--) {
+		tiadc_writel(adc_dev, REG_STEPCONFIG(i), config
+			| STEPCONFIG_INP(chan));
+		tiadc_writel(adc_dev, REG_STEPDELAY(i), STEPCONFIG_OPENDLY);
+		chan--;
 	}
-	tiadc_writel(adc_dev, REG_SE, STPENB_STEPENB);
 }
 
 static int tiadc_channel_init(struct iio_dev *indio_dev,
@@ -100,13 +97,17 @@ static int tiadc_channel_init(struct iio_dev *indio_dev,
 	/* buffer space is after the array */
 	s = (char *)(chan_array + channels);
 	chan = chan_array;
+
+	// The Touch-screen channels are the first channels,
+	// so it makes sence to place the ADC channels after and name them
+	// accordingly.
 	for (i = 0; i < channels; i++, chan++, s += len + 1) {
 
-		len = sprintf(s, "AIN%d", i);
+		len = sprintf(s, "AIN%d", TOTAL_CHANNELS-i-1);
 
 		chan->type = IIO_VOLTAGE;
 		chan->indexed = 1;
-		chan->channel = i;
+		chan->channel = TOTAL_CHANNELS-i-1;
 		chan->datasheet_name = s;
 		chan->scan_type.sign = 'u';
 		chan->scan_type.realbits = 12;
@@ -154,26 +155,18 @@ static int tiadc_read_raw(struct iio_dev *indio_dev,
 {
 	struct tiadc_device *adc_dev = iio_priv(indio_dev);
 	int i;
-	unsigned int fifo1count, readx1;
-
-	/*
-	 * When the sub-system is first enabled,
-	 * the sequencer will always start with the
-	 * lowest step (1) and continue until step (16).
-	 * For ex: If we have enabled 4 ADC channels and
-	 * currently use only 1 out of them, the
-	 * sequencer still configures all the 4 steps,
-	 * leading to 3 unwanted data.
-	 * Hence we need to flush out this data.
-	 */
 
-	fifo1count = tiadc_readl(adc_dev, REG_FIFO1CNT);
-	for (i = 0; i < fifo1count; i++) {
-		readx1 = tiadc_readl(adc_dev, REG_FIFO1);
-		if (i == chan->channel)
-			*val = readx1 & 0xfff;
+	/* Enable the channel via SW. Preempt should cause this to create a
+     * reading even if HW is processing. Since we are only enabling one channel,
+	 * the data in FIFO1 must be the one we want. This assumes FIFO1 is dedicated to ADC.  */
+	i = 100;
+	tiadc_writel(adc_dev, REG_SE, (1<<(TOTAL_STEPS-TOTAL_CHANNELS+chan->channel+1)));
+	while(tiadc_readl(adc_dev, REG_FIFO1CNT) < 1 && --i){
+		msleep(5);
 	}
-	tiadc_writel(adc_dev, REG_SE, STPENB_STEPENB);
+	if(i == 0)
+		return -EBUSY;
+	*val = tiadc_readl(adc_dev, REG_FIFO1)  & 0xfff;
 
 	return IIO_VAL_INT;
 }
diff --git a/drivers/input/touchscreen/ti_am335x_tsc.c b/drivers/input/touchscreen/ti_am335x_tsc.c
index 4fcf72f..130c2d7 100644
--- a/drivers/input/touchscreen/ti_am335x_tsc.c
+++ b/drivers/input/touchscreen/ti_am335x_tsc.c
@@ -211,10 +211,9 @@ static void titsc_step_config(struct titsc *ts_dev)
 		titsc_writel(ts_dev, REG_STEPDELAY(i), STEPCONFIG_OPENDLY);
 	}
 
-	config = 0;
 	config = STEPCONFIG_MODE_HWSYNC |
 			STEPCONFIG_AVG_16 | ts_dev->bit_yn |
-			STEPCONFIG_INM_ADCREFM | STEPCONFIG_FIFO1;
+			STEPCONFIG_INM_ADCREFM;
 	switch (ts_dev->wires) {
 	case 4:
 		config |= ts_dev->bit_yp | STEPCONFIG_INP(ts_dev->inp_xp);
@@ -233,7 +232,6 @@ static void titsc_step_config(struct titsc *ts_dev)
 		titsc_writel(ts_dev, REG_STEPDELAY(i), STEPCONFIG_OPENDLY);
 	}
 
-	config = 0;
 	/* Charge step configuration */
 	config = ts_dev->bit_xp | ts_dev->bit_yn |
 			STEPCHARGE_RFP_XPUL | STEPCHARGE_RFM_XNUR |
@@ -242,7 +240,6 @@ static void titsc_step_config(struct titsc *ts_dev)
 	titsc_writel(ts_dev, REG_CHARGECONFIG, config);
 	titsc_writel(ts_dev, REG_CHARGEDELAY, CHARGEDLY_OPENDLY);
 
-	config = 0;
 	/* Configure to calculate pressure */
 	config = STEPCONFIG_MODE_HWSYNC |
 			STEPCONFIG_AVG_16 | ts_dev->bit_yp |
@@ -252,7 +249,8 @@ static void titsc_step_config(struct titsc *ts_dev)
 	titsc_writel(ts_dev, REG_STEPDELAY(total_steps + 1),
 			STEPCONFIG_OPENDLY);
 
-	config |= STEPCONFIG_INP(ts_dev->inp_yn) | STEPCONFIG_FIFO1;
+
+	config |= STEPCONFIG_INP(ts_dev->inp_yn);
 	titsc_writel(ts_dev, REG_STEPCONFIG(total_steps + 2), config);
 	titsc_writel(ts_dev, REG_STEPDELAY(total_steps + 2),
 			STEPCONFIG_OPENDLY);
@@ -281,12 +279,15 @@ static void titsc_read_coordinates(struct titsc *ts_dev,
 	 * algorithm compares the difference with that of a present value,
 	 * if true the value is reported to the sub system.
 	 */
-	for (i = 0; i < fifocount - 1; i++) {
+
+	// We should have 10 readings now in FIFO 0, leave 2 calculating preassure
+	for (i = 0; i < fifocount-2; i++) {
 		read = titsc_readl(ts_dev, REG_FIFO0);
 		channel = read & 0xf0000;
 		channel = channel >> 0x10;
+		read &= 0xfff;
+
 		if ((channel >= 0) && (channel < ts_dev->steps_to_configure)) {
-			read &= 0xfff;
 			diff = abs(read - prev_val_x);
 			if (diff < prev_diff_x) {
 				prev_diff_x = diff;
@@ -294,13 +295,7 @@ static void titsc_read_coordinates(struct titsc *ts_dev,
 			}
 			prev_val_x = read;
 		}
-
-		read = titsc_readl(ts_dev, REG_FIFO1);
-		channel = read & 0xf0000;
-		channel = channel >> 0x10;
-		if ((channel >= ts_dev->steps_to_configure) &&
-			(channel < (2 * ts_dev->steps_to_configure - 1))) {
-			read &= 0xfff;
+		else{
 			diff = abs(read - prev_val_y);
 			if (diff < prev_diff_y) {
 				prev_diff_y = diff;
@@ -320,7 +315,6 @@ static irqreturn_t titsc_irq(int irq, void *dev)
 	unsigned int z1, z2, z;
 	unsigned int fsm;
 	unsigned int diffx = 0, diffy = 0;
-	int i;
 
 	status = titsc_readl(ts_dev, REG_IRQSTATUS);
 	if (status & IRQENB_FIFO0THRES) {
@@ -331,8 +325,8 @@ static irqreturn_t titsc_irq(int irq, void *dev)
 		ts_dev->bckup_x = x;
 		ts_dev->bckup_y = y;
 
+		z2 = titsc_readl(ts_dev, REG_FIFO0) & 0xfff;
 		z1 = titsc_readl(ts_dev, REG_FIFO0) & 0xfff;
-		z2 = titsc_readl(ts_dev, REG_FIFO1) & 0xfff;
 
 		if (ts_dev->pen_down && z1 != 0 && z2 != 0) {
 			/*
@@ -348,12 +342,15 @@ static irqreturn_t titsc_irq(int irq, void *dev)
 
 			if ((diffx < TSCADC_DELTA_X) &&
 			(diffy < TSCADC_DELTA_Y) && (z <= MAX_12BIT)) {
+				pr_err("Accepted (%d, %d, %d)\n", x, y, z);
 				input_report_abs(input_dev, ABS_X, x);
 				input_report_abs(input_dev, ABS_Y, y);
 				input_report_abs(input_dev, ABS_PRESSURE, z);
 				input_report_key(input_dev, BTN_TOUCH, 1);
 				input_sync(input_dev);
 			}
+			else
+				pr_err("Rejected (%d, %d, %d)\n", x, y, z);
 		}
 		irqclr |= IRQENB_FIFO0THRES;
 	}
diff --git a/drivers/mfd/ti_am335x_tscadc.c b/drivers/mfd/ti_am335x_tscadc.c
index e28a31d..fc8e7de 100644
--- a/drivers/mfd/ti_am335x_tscadc.c
+++ b/drivers/mfd/ti_am335x_tscadc.c
@@ -176,7 +176,8 @@ static	int ti_tscadc_probe(struct platform_device *pdev)
 	ctrl = CNTRLREG_STEPCONFIGWRT |
 			CNTRLREG_TSCENB |
 			CNTRLREG_STEPID |
-			CNTRLREG_4WIRE;
+			CNTRLREG_4WIRE  |
+			CNTRLREG_HWPREEMPT;
 	tscadc_writel(tscadc, REG_CTRL, ctrl);
 
 	/* Set register bits for Idle Config Mode */
diff --git a/drivers/pwm/pwm_test.c b/drivers/pwm/pwm_test.c
index d9948db..1cf35a9d 100644
--- a/drivers/pwm/pwm_test.c
+++ b/drivers/pwm/pwm_test.c
@@ -26,13 +26,14 @@
 #include <linux/err.h>
 #include <linux/clk.h>
 #include <linux/pm_runtime.h>
+#include <linux/pinctrl/consumer.h>
 
 struct pwm_test {
 	struct pwm_device *pwm;
 	int ret;
 	struct class *pwm_test_class;
-	unsigned long period, duty, run, polarity, config, requested;
-	unsigned long period_s, duty_s, run_s, polarity_s, config_s, requested_s;
+	unsigned long period, duty, run, polarity, requested;
+	unsigned long period_s, duty_s, run_s, polarity_s, requested_s;
 	struct device *dev;
 };
 
@@ -52,6 +53,15 @@ static ssize_t pwm_test_store_duty(struct device *dev,
 	rc = kstrtoul(buf, 0, &pwm_test->duty_s);
 	if (rc)
 		return rc;
+
+	rc = pwm_config(pwm_test->pwm, pwm_test->duty_s, pwm_test->period);
+	if (rc) {
+		pr_err("Unable to set pwm duty. Err %d, (duty, period) = (%lu, %lu)\n",
+			rc, pwm_test->duty_s, pwm_test->period);
+		return rc;
+	}
+	pwm_test->duty = pwm_test->duty_s;
+
 	return count;
 }
 
@@ -73,50 +83,13 @@ static ssize_t pwm_test_store_period(struct device *dev,
 	if (rc)
 		return rc;
 
-	return count;
-}
-
-static ssize_t pwm_test_show_config(struct device *dev,
-		struct device_attribute *attr, char *buf)
-{
-	struct pwm_test *pwm_test = dev_get_drvdata(dev);
-	if (pwm_test->config)
-		return sprintf(buf, "config Done\n");
-	else
-		return sprintf(buf, "config Failed\n");
-}
-static ssize_t pwm_test_store_config(struct device *dev,
-		struct device_attribute *attr, const char *buf, size_t count)
-{
-	struct pwm_test *pwm_test = dev_get_drvdata(dev);
-	int ret;
-
-	if (pwm_test->duty_s == 0) {
-		ret = pwm_config(pwm_test->pwm, 0, pwm_test->period_s);
-		if (ret) {
-			pwm_test->config = 0;
-			pr_err("operation failed %d\n", ret);
-			pwm_test->duty_s = pwm_test->duty;
-			pwm_test->period_s = pwm_test->period;
-			return ret;
-		}
-		pwm_test->duty = pwm_test->duty_s;
-		pwm_test->period = pwm_test->period_s;
-		pwm_test->config = 1;
-	} else {
-		ret = pwm_config(pwm_test->pwm, pwm_test->duty_s,
-				pwm_test->period_s);
-		if (ret) {
-			pwm_test->config = 0;
-			pr_err("operation failed %d\n", ret);
-			pwm_test->duty_s = pwm_test->duty;
-			pwm_test->period_s = pwm_test->period;
-			return ret;
-		}
-		pwm_test->duty = pwm_test->duty_s;
-		pwm_test->period = pwm_test->period_s;
-		pwm_test->config = 1;
+	rc = pwm_config(pwm_test->pwm, pwm_test->duty, pwm_test->period_s);
+	if (rc) {
+		pr_err("Unable to set pwm period %d\n", rc);
+		return rc;
 	}
+	pwm_test->period = pwm_test->period_s;
+
 	return count;
 }
 
@@ -199,6 +172,9 @@ static ssize_t pwm_test_store_request(struct device *dev,
 		return rc;
 
 	if (pwm_test->requested_s) {
+		if(pwm_test->requested) // Allready requested
+			return count;
+
 		pwm_test->pwm = pwm_get(dev, NULL);
 
 		if (IS_ERR(pwm_test->pwm)) {
@@ -212,12 +188,10 @@ static ssize_t pwm_test_store_request(struct device *dev,
 		pwm_test->run = 0;
 		pwm_test->duty = 0;
 		pwm_test->period = 0;
-		pwm_test->config = 0;
 		pwm_test->polarity_s = 0;
 		pwm_test->run_s = 0;
 		pwm_test->duty_s = 0;
 		pwm_test->period_s = 0;
-		pwm_test->config_s = 0;
 		rc = 0;
 	}
 
@@ -235,14 +209,12 @@ static DEVICE_ATTR(duty, 0644, pwm_test_show_duty, pwm_test_store_duty);
 static DEVICE_ATTR(period, 0644, pwm_test_show_period, pwm_test_store_period);
 static DEVICE_ATTR(polarity, 0644, pwm_test_show_polarity,
 		pwm_test_store_polarity);
-static DEVICE_ATTR(config, 0644 , pwm_test_show_config, pwm_test_store_config);
 static DEVICE_ATTR(run, 0644 , pwm_test_show_run, pwm_test_store_run);
 static DEVICE_ATTR(request, 0644 , pwm_test_show_request, pwm_test_store_request);
 
 static const struct attribute *pwm_attrs[] = {
 	&dev_attr_duty.attr,
 	&dev_attr_period.attr,
-	&dev_attr_config.attr,
 	&dev_attr_run.attr,
 	&dev_attr_request.attr,
 	&dev_attr_polarity.attr,
@@ -263,6 +235,14 @@ static int __init pwm_test_class_init(struct device *dev)
 static int pwm_test_probe(struct platform_device *pdev)
 {
 	struct pwm_test *pwm_test;
+	struct pinctrl *pinctrl;
+	struct device_node *node = (&pdev->dev)->of_node;
+	int rc;
+
+	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(&pdev->dev, "unable to select pin group. PWM not muxed right\n");
+
 
 	pwm_test = devm_kzalloc(&pdev->dev, sizeof(*pwm_test), GFP_KERNEL);
 
@@ -275,7 +255,43 @@ static int pwm_test_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "sysfs creation failed\n");
 		return -EINVAL;
 	}
-	dev_set_drvdata(&pdev->dev, pwm_test);
+
+	pwm_test->pwm = devm_pwm_get(&pdev->dev, NULL);
+	if (IS_ERR(pwm_test->pwm)) {
+		dev_err(&pdev->dev, "unable to request PWM\n");
+		return -EINVAL;
+	}
+
+	pwm_test->requested = 1;
+
+	pr_debug("pwm_test got PWM\n");
+
+	/* Get the properties of the pwm. This is set in the device driver (tiehrpwm) */
+	pwm_test->period = pwm_get_period(pwm_test->pwm);
+
+	/* Determine running or not from the device tree */
+	rc = of_property_read_u32(node, "enabled", (u32*) &(pwm_test->run));
+	if (rc < 0)
+		return rc;
+
+	if(pwm_test->run){
+		rc = pwm_enable(pwm_test->pwm);
+		if (rc < 0)
+				return rc;
+	}
+
+	/* Determine the duty from the device tree */
+	rc = of_property_read_u32(node, "duty", (u32*) &(pwm_test->duty_s));
+	if (rc < 0)
+		return rc;
+
+	rc = pwm_config(pwm_test->pwm, pwm_test->duty_s, pwm_test->period);
+	if (rc) {
+		pr_err("Unable to set pwm duty %d\n", rc);
+		return rc;
+	}
+
+
 	platform_set_drvdata(pdev, pwm_test);
 	return 0;
 }
@@ -315,6 +331,7 @@ static struct platform_driver pwm_test_driver = {
 	.remove		= pwm_test_remove,
 };
 
+
 module_platform_driver(pwm_test_driver);
 
 MODULE_DESCRIPTION("pwm_test Driver");
diff --git a/firmware/Makefile b/firmware/Makefile
index d4403b5..6b15f24 100644
--- a/firmware/Makefile
+++ b/firmware/Makefile
@@ -174,6 +174,10 @@ fw-shipped-$(CONFIG_CAPE_BEAGLEBONE) += cape-boneblack-hdmi-00A0.dtbo
 # the Tester cape (tester-side)
 fw-shipped-$(CONFIG_CAPE_BEAGLEBONE) += cape-bone-tester-00A0.dtbo
 
+# The Replicape
+fw-shipped-$(CONFIG_CAPE_BEAGLEBONE) += \
+	cape-bone-replicape-00A1.dtbo
+
 fw-shipped-all := $(fw-shipped-y) $(fw-shipped-m) $(fw-shipped-)
 
 # Directories which we _might_ need to create, so we have a rule for them.
diff --git a/firmware/capes/cape-bone-replicape-00A1.dts b/firmware/capes/cape-bone-replicape-00A1.dts
new file mode 100644
index 0000000..da428f4
--- /dev/null
+++ b/firmware/capes/cape-bone-replicape-00A1.dts
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2013 Intelligent Agent AS	<elias@iagent.no>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "ti,beaglebone", "ti,beaglebone-black";
+
+	/* identification */
+	part-number = "BB-BONE-REPLICAP";
+	version = "00A1";
+
+	fragment@0 {
+		target = <&am33xx_pinmux>;
+		__overlay__ {
+			// 	  From Cameon.net
+			//    Bit 5: 1 - Input, 		0 - Output
+			//    Bit 4: 1 - Pull up, 		0 - Pull down
+			//    Bit 3: 1 - Pull disabled, 0 - Pull enabled
+			//    Bit 2: - Mode
+			//    Bit 1: - Mode
+			//    Bit 0: - Mode
+			bone_replicape_spi1_pins: pinmux_replicape_spi1_pins {
+				pinctrl-single,pins = <
+					0x190 0x13	/* P9_31 = mcasp0_aclkx.spi1_sclk				 , OUTPUT_PULLUP | MODE3 */
+					0x194 0x33	/* P9_29 = mcasp0_fsx.spi1_d0					 , INPUT_PULLUP  | MODE3 */
+					0x198 0x13	/* P9_30 = mcasp0_axr0.spi1_d1					 , OUTPUT_PULLUP | MODE3 */
+					0x19c 0x13	/* P9_28 = mcasp0_ahclkr.spi1_cs0				 , OUTPUT_PULLUP | MODE3 */
+					0x164 0x12  /* P9_42 = GPIO0_7 =  eCAP0_in_PWM0_out.gpio0[7] , OUTPUT_PULLUP | MODE2 */
+				>;
+			};
+			pwm_mosfet_ext1_pins: pinmux_pwm_mosfet_ext1_pins {
+				pinctrl-single,pins = <
+					0x024  0x4		/* P8_13 = gpmc_ad9  = ehrpwm2B = Heater_ext1 | MODE 4 */
+				>;
+			};
+			pwm_mosfet_ext2_pins: pinmux_pwm_mosfet_ext2_pins {
+				pinctrl-single,pins = <
+					0x020  0x4      /* P8_19 = gpmc_ad8  = ehrpwm2A = Heater_ext2 | MODE 4 */
+				>;
+			};
+			pruicss_stepper_pins: pinmux_pruicss_stepper_pins{
+				pinctrl-single,pins = <
+					0x018 0x07 /* P8_3  = DIR_EXT_2  = GPIO1_6    gpmc_ad6.gpio1[6]      	*/
+					0x01C 0x07 /* P8_4  = DIR_EXT_1  = GPIO1_7    gpmc_ad7.gpio1[7]      	*/
+					0x008 0x07 /* P8_5  = DIR_Z   	 = GPIO1_2    gpmc_ad2.gpio1[2]      	*/
+					0x034 0x07 /* P8_11 = DIR_X   	 = GPIO1_13   gpmc_ad13.gpio1[13]    	*/
+					0x030 0x07 /* P8_12 = STEP_X  	 = GPIO1_12   gpmc_ad12.gpio1[12]    	*/
+					0x038 0x07 /* P8_16 = STEP_EXT_2 = GPIO1_14   gpmc_ad14.gpio1[14]    	*/
+					0x084 0x07 /* P8_20 = STEP_Y	 = GPIO1_31   gpmc_csn2.gpio1[31]    	*/
+					0x080 0x07 /* P8_21 = DIR_Y		 = GPIO1_30   gpmc_csn1.gpio1[30]    	*/
+					0x004 0x07 /* P8_24 = STEP_Z 	 = GPIO1_1    gpmc_ad1 .gpio1[1]	 	*/
+					0x1AC 0x07 /* P9_25	= STEP_EXT_1 = GPIO3_21	  mcasp0_ahclkx.gpio3[21]	*/
+				>;
+			};
+
+			pwm_mosfet_hbp_pins: pinmux_pwm_mosfet_hbp_pins {
+				pinctrl-single,pins = <
+					0x150  0x3		/* P9_14 = spi0_sclk = ehrpwm0A = Heater_HBP  | MODE 3 */
+				>;
+			};
+
+			pruicss_fault_pins: pinmux_pruicss_fault_pins{
+				pinctrl-single,pins = <
+					0x094 0x37 // P8_8  = FAULT_EXT_2 = GPIO2_2    gpmc_oen_ren.gpio2[3]
+					0x098 0x37 // P8_10 = FAULT_X     = GPIO2_4    gpmc_wen.gpio2[4]
+				>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&spi1>;
+		__overlay__ {
+			#address-cells 	= <1>;
+			#size-cells 	= <0>;
+			status			= "okay";
+			pinctrl-names	= "default";
+			pinctrl-0		= <&bone_replicape_spi1_pins>;
+			cs-gpios 		= <&gpio4 17 0>, <&gpio1 7 0>;
+
+			stepper_control{
+				#address-cells 	  = <1>;
+				#size-cells 	  = <0>;
+				compatible 		  = "spidev";
+				reg 			  = <0>;
+				spi-max-frequency = <16000000>;
+				spi-cpha;		  // Stepper control has mode 1 (CPOL = 0, CPHA = 1)
+			};
+
+			stepper_current{
+				#address-cells 	  = <1>;
+				#size-cells 	  = <0>;
+				compatible 		  = "spidev";
+				reg 			  = <1>;
+				spi-max-frequency = <16000000>;
+								  // Stepper current has mode 0 (CPOL = 0, CPHA = 0)
+			};
+		};
+	};
+	fragment@2 {
+		target = <&epwmss2>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&ehrpwm2>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&epwmss0>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&ehrpwm0>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6{
+		target = <&pruss>;
+		__overlay__{
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 	  = <&pruicss_stepper_pins>;
+
+			stepper_x{
+				pin-names 	= "Replic:pru-step_x", "Replic:pru-dir_x";
+				gpios 		= <&gpio2 12 0
+							   &gpio2 13 0>;
+			};
+			stepper_y{
+				pin-names 	= "Replic:pru-step_y", "Replic:pru-dir_y";
+				gpios 		=<&gpio2 31 0
+							  &gpio2 30 0>;
+			};
+			stepper_z{
+				pin-names 	= "Replic:pru-step_z", "Replic:pru-dir_z";
+				gpios 		= <&gpio2 1 0
+							   &gpio2 2 0>;
+			};
+			stepper_ext_1{
+				pin-names 	= "Replic:pru-step_ext_1", "Replic:pru-dir_ext_1";
+				gpios 		= <&gpio4 21 0
+							   &gpio2 7 0>;
+			};
+			stepper_ext_2{
+				pin-names 	= "Replic:pru-step_ext_2", "Replic:pru-dir_ext_2";
+				gpios 		= <&gpio2 14 0
+							   &gpio2 6 0>;
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&ocp>;
+		__overlay__ {
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			mosfet_ext1 {
+				compatible      = "pwm_test";
+				pinctrl-names   = "default";
+				pinctrl-0       = <&pwm_mosfet_ext1_pins>;
+				pwms 			= <&ehrpwm2 1 500000 1>;
+				pwm-names 		= "Mosfet_Ext_1";
+				enabled			= <1>;
+				polarity		= <1>; // 0 = normal, 1 = inverse
+				duty			= <0>;
+				status 			= "okay";
+			};
+			mosfet_ext2 {
+				compatible      = "pwm_test";
+				pinctrl-names   = "default";
+				pinctrl-0       = <&pwm_mosfet_ext2_pins>;
+				pwms 			= <&ehrpwm2 0 500000 1>;
+				pwm-names 		= "Mosfet_Ext_2";
+				enabled			= <1>;
+				duty			= <0>;
+				status 			= "okay";
+			};
+			mosfet_hbp {
+				compatible      = "pwm_test";
+				pinctrl-names   = "default";
+				pinctrl-0       = <&pwm_mosfet_hbp_pins>;
+				pwms 			= <&ehrpwm0 0 500000 1>;
+				pwm-names 		= "Mosfet_HBP";
+				enabled			= <1>;
+				duty			= <0>;
+				status 			= "okay";
+			};
+
+			thermistors{
+				compatible = "bone-iio-helper";
+				vsense-name  = "AIN4", "AIN5", "AIN6", "AIN7";
+				vsense-scale = <100     100     100     100 >;
+				status = "okay";
+			};
+		};
+	};
+
+};
diff --git a/include/linux/mfd/ti_am335x_tscadc.h b/include/linux/mfd/ti_am335x_tscadc.h
index 50a245f..9fe52ba 100644
--- a/include/linux/mfd/ti_am335x_tscadc.h
+++ b/include/linux/mfd/ti_am335x_tscadc.h
@@ -113,6 +113,8 @@
 #define CNTRLREG_5WIRE		CNTRLREG_AFE_CTRL(2)
 #define CNTRLREG_8WIRE		CNTRLREG_AFE_CTRL(3)
 #define CNTRLREG_TSCENB		BIT(7)
+#define CNTRLREG_HW_EVT_MAP BIT(8)
+#define CNTRLREG_HWPREEMPT  BIT(9)
 
 #define XPP			STEPCONFIG_XPP
 #define XNP			STEPCONFIG_XNP
-- 
1.7.10.4

