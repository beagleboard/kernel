From 763cdd2f59d2f13abcd02dd036d3bbffef4cabc3 Mon Sep 17 00:00:00 2001
From: Pantelis Antoniou <panto@antoniou-consulting.com>
Date: Sat, 20 Oct 2012 11:10:46 +0300
Subject: [PATCH 28/52] capebus: Move bone generic support to own file

---
 drivers/capebus/boards/Makefile               |    4 +-
 drivers/capebus/boards/capebus-bone-generic.c |  213 +++++++++++++++++++++++++
 drivers/capebus/boards/capebus-bone-pdevs.c   |  150 -----------------
 drivers/capebus/capebus-driver.c              |    2 +-
 4 files changed, 217 insertions(+), 152 deletions(-)
 create mode 100644 drivers/capebus/boards/capebus-bone-generic.c

diff --git a/drivers/capebus/boards/Makefile b/drivers/capebus/boards/Makefile
index bff281e..9048231 100644
--- a/drivers/capebus/boards/Makefile
+++ b/drivers/capebus/boards/Makefile
@@ -1 +1,3 @@
-obj-$(CONFIG_CAPEBUS_BONE_CONTROLLER)	+= capebus-bone.o capebus-bone-pdevs.o
+obj-$(CONFIG_CAPEBUS_BONE_CONTROLLER)	+= capebus-bone.o \
+					   capebus-bone-pdevs.o \
+					   capebus-bone-generic.o \
diff --git a/drivers/capebus/boards/capebus-bone-generic.c b/drivers/capebus/boards/capebus-bone-generic.c
new file mode 100644
index 0000000..abd5027
--- /dev/null
+++ b/drivers/capebus/boards/capebus-bone-generic.c
@@ -0,0 +1,213 @@
+/*
+ * TI Beaglebone capebus controller - Generic devices
+ *
+ * Copyright (C) 2012 Pantelis Antoniou <panto@antoniou-consulting.com>
+ * Copyright (C) 2012 Texas Instruments Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <video/da8xx-fb.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/atomic.h>
+#include <linux/clk.h>
+#include <asm/barrier.h>
+#include <plat/clock.h>
+#include <plat/omap_device.h>
+#include <linux/clkdev.h>
+#include <linux/input/ti_tsc.h>
+#include <linux/platform_data/ti_adc.h>
+#include <linux/mfd/ti_tscadc.h>
+
+#include <linux/capebus/capebus-bone.h>
+
+int bone_capebus_probe_prolog(struct cape_dev *dev,
+		const struct cape_device_id *id)
+{
+	char boardbuf[33];
+	char versionbuf[5];
+	const char *board_name;
+	const char *version;
+	const struct of_device_id *match;
+	struct pinctrl *pinctrl;
+
+	/* get the board name (also matches the cntrlboard before checking) */
+	board_name = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME,
+			boardbuf, sizeof(boardbuf));
+	if (board_name == NULL)
+		return -ENODEV;
+
+	/* match compatible? */
+	match = capebus_of_match_device(dev, "board-name", board_name);
+	if (match == NULL)
+		return -ENODEV;
+
+	/* get the board version */
+	version = bone_capebus_id_get_field(id, BONE_CAPEBUS_VERSION,
+			versionbuf, sizeof(versionbuf));
+	if (version == NULL)
+		return -ENODEV;
+
+	pinctrl = devm_pinctrl_get_select_default(&dev->dev);
+	if (IS_ERR(pinctrl))
+		dev_warn(&dev->dev,
+			"pins are not configured from the driver\n");
+
+	dev_info(&dev->dev, "%s: V=%s '%s'\n", board_name,
+			version, match->compatible);
+
+	return 0;
+}
+EXPORT_SYMBOL(bone_capebus_probe_prolog);
+
+static const struct bone_capebus_generic_device_data gendevs[] = {
+	{
+		.name	= "leds",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "gpio-leds", }, { },
+			},
+		.units	 = 0,	/* no limit */
+	}, {
+		.name	= "tps-bl",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "tps65217-backlight", }, { },
+			},
+		.units	 = 0,	/* no limit */
+	}, {
+		.name	= "keys",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "gpio-keys", }, { },
+			},
+		.units	 = 0,	/* no limit */
+	}, {
+		.name	= "tscadc",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "ti-tscadc-dt", }, { },
+			},
+		.units	 = 1,
+	}, {
+		.name	= "lcdc",
+		.of_match = (const struct of_device_id []) {
+				{ .compatible = "da8xx-dt", }, { },
+			},
+		.units	 = 1,
+	},
+};
+
+struct bone_capebus_generic_info *
+bone_capebus_probe_generic(struct cape_dev *dev,
+		const struct cape_device_id *id)
+{
+	struct bone_capebus_generic_info *info;
+	char boardbuf[33];
+	char versionbuf[5];
+	const char *board_name;
+	const char *version;
+	struct platform_device *pdev;
+	const struct bone_capebus_generic_device_data *dd;
+	struct bone_capebus_generic_device_entry *de;
+	int i;
+
+	/* get the board name (also matches the cntrlboard before checking) */
+	board_name = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME,
+			boardbuf, sizeof(boardbuf));
+	/* get the board version */
+	version = bone_capebus_id_get_field(id, BONE_CAPEBUS_VERSION,
+			versionbuf, sizeof(versionbuf));
+
+	/* should never happen, but it doesn't hurt to play it safe */
+	if (board_name == NULL || version == NULL)
+		return ERR_PTR(-ENODEV);
+
+	info = devm_kzalloc(&dev->dev, sizeof(*info), GFP_KERNEL);
+	if (info == NULL) {
+		dev_err(&dev->dev, "Failed to allocate info\n");
+		return ERR_PTR(-ENOMEM);
+	}
+	info->dev = dev;
+	INIT_LIST_HEAD(&info->pdev_list);
+
+	/* iterate over the supported devices */
+	for (i = 0, dd = gendevs; i < ARRAY_SIZE(gendevs); i++, dd++) {
+
+		pdev = capebus_of_platform_compatible_device_create(dev,
+			dd->of_match, dd->name, "version", version);
+
+		/* node not found (mostly harmless) */
+		if (IS_ERR(pdev) && PTR_ERR(pdev) == -ENXIO) {
+			/* TODO: deal with required nodes */
+			continue;
+		}
+
+		/* failed to create due to an error; fatal */
+		if (IS_ERR_OR_NULL(pdev)) {
+			dev_err(&dev->dev, "failed to create device %s\n",
+					dd->name);
+			goto err_fail;
+		}
+
+		de = devm_kzalloc(&dev->dev, sizeof(*de), GFP_KERNEL);
+		if (de == NULL) {
+			dev_err(&dev->dev, "failed to allocate entry for %s\n",
+					dd->name);
+			goto err_fail;
+		}
+
+		/* add it to the list */
+		de->data = dd;
+		de->pdev = pdev;
+		list_add_tail(&de->node, &info->pdev_list);
+	}
+
+	return info;
+
+err_fail:
+	bone_capebus_remove_generic(info);
+	return NULL;
+}
+EXPORT_SYMBOL(bone_capebus_probe_generic);
+
+void bone_capebus_remove_generic(struct bone_capebus_generic_info *info)
+{
+	struct list_head *lh, *lhn;
+	struct bone_capebus_generic_device_entry *de;
+
+	if (info == NULL || info->dev == NULL)
+		return;
+
+	list_for_each_safe(lh, lhn, &info->pdev_list) {
+		de = list_entry(lh, struct bone_capebus_generic_device_entry,
+				node);
+		list_del(lh);
+		platform_device_unregister(de->pdev);
+		devm_kfree(&info->dev->dev, de);
+	}
+	devm_kfree(&info->dev->dev, info);
+}
+EXPORT_SYMBOL(bone_capebus_remove_generic);
diff --git a/drivers/capebus/boards/capebus-bone-pdevs.c b/drivers/capebus/boards/capebus-bone-pdevs.c
index 3ee8601..fd91208 100644
--- a/drivers/capebus/boards/capebus-bone-pdevs.c
+++ b/drivers/capebus/boards/capebus-bone-pdevs.c
@@ -384,153 +384,3 @@ void bone_capebus_unregister_pdev_adapters(struct bone_capebus_bus *bus)
 		drvp->registered = 0;
 	}
 }
-
-int bone_capebus_probe_prolog(struct cape_dev *dev,
-		const struct cape_device_id *id)
-{
-	char boardbuf[33];
-	char versionbuf[5];
-	const char *board_name;
-	const char *version;
-	const struct of_device_id *match;
-	struct pinctrl *pinctrl;
-
-	/* get the board name (also matches the cntrlboard before checking) */
-	board_name = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME,
-			boardbuf, sizeof(boardbuf));
-	if (board_name == NULL)
-		return -ENODEV;
-
-	/* match compatible? */
-	match = capebus_of_match_device(dev, "board-name", board_name);
-	if (match == NULL)
-		return -ENODEV;
-
-	/* get the board version */
-	version = bone_capebus_id_get_field(id, BONE_CAPEBUS_VERSION,
-			versionbuf, sizeof(versionbuf));
-	if (version == NULL)
-		return -ENODEV;
-
-	pinctrl = devm_pinctrl_get_select_default(&dev->dev);
-	if (IS_ERR(pinctrl))
-		dev_warn(&dev->dev,
-			"pins are not configured from the driver\n");
-
-	dev_info(&dev->dev, "%s: V=%s '%s'\n", board_name,
-			version, match->compatible);
-
-	return 0;
-}
-EXPORT_SYMBOL(bone_capebus_probe_prolog);
-
-static const struct bone_capebus_generic_device_data gendevs[] = {
-	{
-		.name	= "leds",
-		.of_match = (const struct of_device_id []) {
-				{ .compatible = "gpio-leds", }, { },
-			},
-		.units	 = 0,	/* no limit */
-	}, {
-		.name	= "tps-bl",
-		.of_match = (const struct of_device_id []) {
-				{ .compatible = "tps65217-backlight", }, { },
-			},
-		.units	 = 0,	/* no limit */
-	}, {
-		.name	= "keys",
-		.of_match = (const struct of_device_id []) {
-				{ .compatible = "gpio-keys", }, { },
-			},
-		.units	 = 0,	/* no limit */
-	}, {
-		.name	= "tscadc",
-		.of_match = (const struct of_device_id []) {
-				{ .compatible = "ti-tscadc-dt", }, { },
-			},
-		.units	 = 1,
-	}, {
-		.name	= "lcdc",
-		.of_match = (const struct of_device_id []) {
-				{ .compatible = "da8xx-dt", }, { },
-			},
-		.units	 = 1,
-	},
-};
-
-struct bone_capebus_generic_info *
-bone_capebus_probe_generic(struct cape_dev *dev,
-		const struct cape_device_id *id)
-{
-	struct bone_capebus_generic_info *info;
-	char boardbuf[33];
-	char versionbuf[5];
-	const char *board_name;
-	const char *version;
-	struct platform_device *pdev;
-	const struct bone_capebus_generic_device_data *dd;
-	struct bone_capebus_generic_device_entry *de;
-	int i;
-
-	/* get the board name (also matches the cntrlboard before checking) */
-	board_name = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME,
-			boardbuf, sizeof(boardbuf));
-	/* get the board version */
-	version = bone_capebus_id_get_field(id, BONE_CAPEBUS_VERSION,
-			versionbuf, sizeof(versionbuf));
-
-	/* should never happen, but it doesn't hurt to play it safe */
-	if (board_name == NULL || version == NULL)
-		return ERR_PTR(-ENODEV);
-
-	info = devm_kzalloc(&dev->dev, sizeof(*info), GFP_KERNEL);
-	if (info == NULL) {
-		dev_err(&dev->dev, "Failed to allocate info\n");
-		return ERR_PTR(-ENOMEM);
-	}
-	info->dev = dev;
-	INIT_LIST_HEAD(&info->pdev_list);
-
-	/* iterate over the supported devices */
-	for (i = 0, dd = gendevs; i < ARRAY_SIZE(gendevs); i++, dd++) {
-		pdev = capebus_of_platform_compatible_device_create(dev,
-			dd->of_match, dd->name, "version", version);
-		if (IS_ERR(pdev))
-			pdev = NULL;
-
-		if (pdev == NULL)
-			continue;
-
-		de = devm_kzalloc(&dev->dev, sizeof(*de), GFP_KERNEL);
-		if (de == NULL) {
-			dev_err(&dev->dev, "failed to allocate entry for %s\n",
-					dd->name);
-			platform_device_unregister(pdev);
-			continue;
-		}
-
-		/* add it to the list */
-		de->data = dd;
-		de->pdev = pdev;
-		list_add_tail(&de->node, &info->pdev_list);
-	}
-
-	return info;
-}
-EXPORT_SYMBOL(bone_capebus_probe_generic);
-
-void bone_capebus_remove_generic(struct bone_capebus_generic_info *info)
-{
-	struct list_head *lh, *lhn;
-	struct bone_capebus_generic_device_entry *de;
-
-	list_for_each_safe(lh, lhn, &info->pdev_list) {
-		de = list_entry(lh, struct bone_capebus_generic_device_entry,
-				node);
-		list_del(lh);
-		platform_device_unregister(de->pdev);
-		devm_kfree(&info->dev->dev, de);
-	}
-	devm_kfree(&info->dev->dev, info);
-}
-EXPORT_SYMBOL(bone_capebus_remove_generic);
diff --git a/drivers/capebus/capebus-driver.c b/drivers/capebus/capebus-driver.c
index 5679385..794a970 100644
--- a/drivers/capebus/capebus-driver.c
+++ b/drivers/capebus/capebus-driver.c
@@ -458,7 +458,7 @@ capebus_of_platform_compatible_device_create(struct cape_dev *dev,
 	node = capebus_of_compatible_device_property_match(dev, matches, prop,
 			prop_value);
 	if (node == NULL)
-		return ERR_PTR(-ENODEV);
+		return ERR_PTR(-ENXIO);
 
 	pdev = of_platform_device_create(node, pdev_name, dev->bus->dev.parent);
 
-- 
1.7.7.6

