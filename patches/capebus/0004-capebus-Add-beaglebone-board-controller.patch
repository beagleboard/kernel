From 30342be9c83b8db6bca4ea6b228fc7e21abef515 Mon Sep 17 00:00:00 2001
From: Pantelis Antoniou <panto@antoniou-consulting.com>
Date: Sat, 13 Oct 2012 18:26:19 +0300
Subject: [PATCH 04/12] capebus: Add beaglebone board controller

---
 drivers/capebus/boards/Kconfig        |    6 +
 drivers/capebus/boards/Makefile       |    1 +
 drivers/capebus/boards/capebus-bone.c |  730 +++++++++++++++++++++++++++++++++
 include/linux/capebus/capebus-bone.h  |   86 ++++
 4 files changed, 823 insertions(+), 0 deletions(-)
 create mode 100644 drivers/capebus/boards/Kconfig
 create mode 100644 drivers/capebus/boards/Makefile
 create mode 100644 drivers/capebus/boards/capebus-bone.c
 create mode 100644 include/linux/capebus/capebus-bone.h

diff --git a/drivers/capebus/boards/Kconfig b/drivers/capebus/boards/Kconfig
new file mode 100644
index 0000000..499b31e
--- /dev/null
+++ b/drivers/capebus/boards/Kconfig
@@ -0,0 +1,6 @@
+config CAPEBUS_BONE_CONTROLLER
+	bool "Beaglebone capebus board controller"
+	depends on CAPEBUS_CORE && ARCH_OMAP2PLUS && OF && I2C
+	default n
+	help
+	  "Select this to enable the beaglebone capebus board controller"
diff --git a/drivers/capebus/boards/Makefile b/drivers/capebus/boards/Makefile
new file mode 100644
index 0000000..1a8847b
--- /dev/null
+++ b/drivers/capebus/boards/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_CAPEBUS_BONE_CONTROLLER)	+= capebus-bone.o
diff --git a/drivers/capebus/boards/capebus-bone.c b/drivers/capebus/boards/capebus-bone.c
new file mode 100644
index 0000000..b168027
--- /dev/null
+++ b/drivers/capebus/boards/capebus-bone.c
@@ -0,0 +1,730 @@
+/*
+ * TI Beaglebone capebus controller
+ *
+ * Copyright (C) 2012 Pantelis Antoniou <panto@antoniou-consulting.com>
+ * Copyright (C) 2012 Texas Instruments Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_i2c.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/err.h>
+
+#include <linux/capebus.h>
+#include <linux/capebus/capebus-bone.h>
+
+/* what to fill in to the cntrlboard field of the id */
+#define BONE_CAPEBUS_CNTRLBOARD		"beaglebone"
+
+/* various EEPROM definition for the bone */
+struct bone_capebus_eeprom_field {
+	const char 	*name;
+	int 		start;
+	int		size;
+	unsigned int	ascii : 1;
+	unsigned int	strip_trailing_dots : 1;
+};
+
+static const struct bone_capebus_eeprom_field eeprom_fields[] = {
+	[BONE_CAPEBUS_HEADER] = {
+		.name		= "header",
+		.start		= 0,
+		.size		= 4,
+		.ascii		= 0,
+	},
+	[BONE_CAPEBUS_EEPROM_REV] = {
+		.name		= "eeprom-format-revision",
+		.start		= 4,
+		.size		= 2,
+		.ascii		= 1,
+	},
+	[BONE_CAPEBUS_BOARD_NAME] = {
+		.name		= "board-name",
+		.start		= 6,
+		.size		= 32,
+		.ascii		= 1,
+		.strip_trailing_dots = 1,
+	},
+	[BONE_CAPEBUS_VERSION] = {
+		.name		= "version",
+		.start		= 38,
+		.size		= 4,
+		.ascii		= 1,
+	},
+	[BONE_CAPEBUS_MANUFACTURER] = {
+		.name		= "manufacturer",
+		.start		= 42,
+		.size		= 16,
+		.ascii		= 1,
+		.strip_trailing_dots = 1,
+	},
+	[BONE_CAPEBUS_PART_NUMBER] = {
+		.name		= "part-number",
+		.start		= 58,
+		.size		= 16,
+		.ascii		= 1,
+	},
+	[BONE_CAPEBUS_NUMBER_OF_PINS] = {
+		.name		= "number-of-pins",
+		.start		= 74,
+		.size		= 2,
+		.ascii		= 0,
+	},
+	[BONE_CAPEBUS_SERIAL_NUMBER] = {
+		.name		= "serial-number",
+		.start		= 76,
+		.size		= 12,
+		.ascii		= 1,
+	},
+	[BONE_CAPEBUS_PIN_USAGE] = {
+		.name		= "pin-usage",
+		.start		= 88,
+		.size		= 140,
+		.ascii		= 0,
+	},
+	[BONE_CAPEBUS_VDD_3V3EXP] = {
+		.name		= "vdd-3v3exp",
+		.start		= 228,
+		.size		= 2,
+		.ascii		= 0,
+	},
+	[BONE_CAPEBUS_VDD_5V] = {
+		.name		= "vdd-5v",
+		.start		= 230,
+		.size		= 2,
+		.ascii		= 0,
+	},
+	[BONE_CAPEBUS_SYS_5V] = {
+		.name		= "sys-5v",
+		.start		= 232,
+		.size		= 2,
+		.ascii		= 0,
+	},
+	[BONE_CAPEBUS_DC_SUPPLIED] = {
+		.name		= "dc-supplied",
+		.start		= 234,
+		.size		= 2,
+		.ascii		= 0,
+	},
+};
+
+/* template to use when using overrides */
+static const u8 eeprom_signature_template[256] = {
+	/* 00-03 - header */
+	0xaa, 0x55, 0x33, 0xee,
+	/* 04-05 - eeprom format revision - A0 */
+	0x41, 0x30,
+	/* 06-25 - board name (empty) */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	/* 26-29 - version - 00A0 */
+	0x30, 0x30, 0xa0, 0x30,
+	/* all the others are zero */
+};
+
+char *bone_capebus_id_get_field(const struct cape_device_id *id,
+		int field, char *buf, int bufsz)
+{
+	const struct bone_capebus_eeprom_field *ee_field;
+	int len;
+
+	/* make sure the ID is valid for the bone */
+	if (bone_capebus_match_cntrlboard(id) != 0)
+		return NULL;
+
+	if ((unsigned int)field >= ARRAY_SIZE(eeprom_fields))
+		return NULL;
+
+	ee_field = &eeprom_fields[field];
+
+	/* enough space? */
+	if (bufsz < ee_field->size + ee_field->ascii)
+		return NULL;
+
+	memcpy(buf, (char *)id->data + ee_field->start, ee_field->size);
+
+	/* terminate ascii field */
+	if (ee_field->ascii)
+		buf[ee_field->size] = '\0';;
+
+	if (ee_field->strip_trailing_dots) {
+		len = strlen(buf);
+		while (len > 1 && buf[len - 1] == '.')
+			buf[--len] = '\0';
+	}
+
+	return buf;
+}
+EXPORT_SYMBOL(bone_capebus_id_get_field);
+
+int bone_capebus_match_cntrlboard(const struct cape_device_id *id)
+{
+	if (strcmp(id->cntrlboard, BONE_CAPEBUS_CNTRLBOARD) != 0)
+		return -ENODEV;
+	return 0;
+}
+EXPORT_SYMBOL(bone_capebus_match_cntrlboard);
+
+int bone_capebus_match_board(const struct cape_device_id *id,
+		const char **board_names)
+{
+	char rname[33];
+	const char *s;
+	int ret;
+	int i;
+
+	/* be safe; check for matching cntrlboard */
+	ret = bone_capebus_match_cntrlboard(id);
+	if (ret != 0)
+		return ret;
+
+	s = bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME,
+			rname, sizeof(rname));
+	if (s == NULL)
+		return -EINVAL;
+
+	i = 0;
+	while (*board_names) {
+		if (strcmp(rname, *board_names) == 0)
+			return i;
+		board_names++;
+	}
+
+	return -1;
+}
+EXPORT_SYMBOL(bone_capebus_match_board);
+
+#ifdef CONFIG_OF
+static const struct of_device_id bone_capebus_of_match[] = {
+	{
+		.compatible = "bone-capebus",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, bone_capebus_of_match);
+
+static const struct of_device_id slot_override_of_match[] = {
+	{
+		.compatible = "bone-capebus-slot-override",
+	},
+	{ },
+};
+
+#endif
+
+const struct cape_device_id *bone_capebus_get_dev_id(struct cape_slot *slot)
+{
+	struct cape_bus *bus = slot->bus;
+	struct bone_capebus_slot *bone_slot = to_bone_capebus_slot(slot);
+	struct i2c_client *client = bone_slot->client;
+	struct cape_device_id *id;
+	const u8 *p;
+	int r;
+
+	id = &bone_slot->id;
+
+	/* need to read EEPROM? */
+	if (!bone_slot->eeprom_probed) {
+
+		bone_slot->eeprom_probed = 1;
+
+		if (!bone_slot->eeprom_override) {
+			r = i2c_memory_read(bone_slot->client,
+				bone_slot->eeprom_signature, 0,
+				sizeof(bone_slot->eeprom_signature));
+			if (r != sizeof(bone_slot->eeprom_signature)) {
+				dev_err(&bus->dev,
+					"bone: Failed to read EEPROM at "
+					"slot %d (addr 0x%02x)\n",
+					slot->slotno, client->addr & 0x7f);
+				bone_slot->eeprom_failed = 1;
+				return NULL;
+			}
+		} else
+			dev_info(&bus->dev,
+				"bone: Using override eeprom data at slot %d\n",
+				slot->slotno);
+
+		p = bone_slot->eeprom_signature;
+		if (BONE_CAPEBUS_MAKE_HEADER(p) != BONE_CAPEBUS_HEADER_VALID) {
+			dev_err(&bus->dev, "bone: Invalid EEPROM signature "
+				"'%08x' at slot %d (addr 0x%02x)\n",
+				BONE_CAPEBUS_MAKE_HEADER(p),
+				slot->slotno, client->addr & 0x7f);
+			bone_slot->eeprom_failed = 1;
+			return NULL;
+		}
+
+		bone_slot->id.cntrlboard = BONE_CAPEBUS_CNTRLBOARD;
+		bone_slot->id.len = sizeof(bone_slot->eeprom_signature);
+		bone_slot->id.data = bone_slot->eeprom_signature;
+
+		bone_capebus_id_get_field(id, BONE_CAPEBUS_BOARD_NAME,
+					bone_slot->text_id,
+					sizeof(bone_slot->text_id));
+
+	}
+
+	/* slot has failed and we don't support hotpluging */
+	if (bone_slot->eeprom_failed)
+		return NULL;
+
+	return id;
+}
+
+const char *bone_capebus_get_text_dev_id(struct cape_slot *slot)
+{
+	struct bone_capebus_slot *bone_slot = to_bone_capebus_slot(slot);
+
+	if (bone_slot->eeprom_failed || !bone_slot->eeprom_probed)
+		return NULL;
+
+	return bone_slot->text_id;
+}
+
+struct bonedev_ee_attribute {
+	struct device_attribute devattr;
+	unsigned int field;
+};
+#define to_bonedev_ee_attribute(x) \
+	container_of((x), struct bonedev_ee_attribute, devattr)
+
+static ssize_t bonedev_ee_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct bonedev_ee_attribute *ee_attr = to_bonedev_ee_attribute(attr);
+	struct cape_dev *cdev = to_cape_dev(dev);
+	const struct cape_device_id *id = cdev->id;
+	const struct bone_capebus_eeprom_field *ee_field;
+	int i, len;
+	char *p, *s;
+	u16 val;
+
+	if (id == NULL)
+		return -EINVAL;
+
+	/* add newline for ascii fields */
+	ee_field = &eeprom_fields[ee_attr->field];
+
+	len = ee_field->size + ee_field->ascii;
+	p = kmalloc(len, GFP_KERNEL);
+	if (p == NULL)
+		return -ENOMEM;
+
+	s = bone_capebus_id_get_field(id, ee_attr->field, p, len);
+	if (s == NULL)
+		return -EINVAL;
+
+	/* add newline for ascii fields and return */
+	if (ee_field->ascii) {
+		len = sprintf(buf, "%s\n", s);
+		goto out;
+	}
+
+	/* case by case handling */
+	switch (ee_attr->field) {
+		case BONE_CAPEBUS_HEADER:
+			len = sprintf(buf, "%02x %02x %02x %02x\n",
+					s[0], s[1], s[2], s[3]);
+			break;
+
+			/* 2 bytes */
+		case BONE_CAPEBUS_NUMBER_OF_PINS:
+		case BONE_CAPEBUS_VDD_3V3EXP:
+		case BONE_CAPEBUS_VDD_5V:
+		case BONE_CAPEBUS_SYS_5V:
+		case BONE_CAPEBUS_DC_SUPPLIED:
+			/* the bone is LE */
+			val = s[0] & (s[1] << 8);
+			len = sprintf(buf, "%u\n", (unsigned int)val & 0xffff);
+			break;
+
+		case BONE_CAPEBUS_PIN_USAGE:
+
+			len = 0;
+			for (i = 0; i < ee_field->size / 2; i++) {
+				/* the bone is LE */
+				val = s[0] & (s[1] << 8);
+				sprintf(buf, "%04x\n", val);
+				buf += 5;
+				len += 5;
+				s += 2;
+			}
+
+			break;
+
+		default:
+			*buf = '\0';
+			len = 0;
+			break;
+	}
+
+out:
+	kfree(p);
+
+	return len;
+}
+
+#define BONEDEV_EE_ATTR(_name, _field) \
+	{ \
+		.devattr = __ATTR(_name, 0440, bonedev_ee_show, NULL), \
+		.field = BONE_CAPEBUS_##_field , \
+	}
+
+struct bonedev_ee_attribute ee_attrs[] = {
+	BONEDEV_EE_ATTR(header, HEADER),
+	BONEDEV_EE_ATTR(eeprom-format-revision, EEPROM_REV),
+	BONEDEV_EE_ATTR(board-name, BOARD_NAME),
+	BONEDEV_EE_ATTR(version, VERSION),
+	BONEDEV_EE_ATTR(manufacturer, MANUFACTURER),
+	BONEDEV_EE_ATTR(part-number, PART_NUMBER),
+	BONEDEV_EE_ATTR(number-of-pins, NUMBER_OF_PINS),
+	BONEDEV_EE_ATTR(serial-number, SERIAL_NUMBER),
+	BONEDEV_EE_ATTR(pin-usage, PIN_USAGE),
+	BONEDEV_EE_ATTR(vdd-3v3exp, VDD_3V3EXP),
+	BONEDEV_EE_ATTR(vdd-5v, VDD_5V),
+	BONEDEV_EE_ATTR(sys-5v, SYS_5V),
+	BONEDEV_EE_ATTR(dc-supplied, DC_SUPPLIED),
+};
+
+static int bone_capebus_sysfs_register(struct cape_dev *dev)
+{
+	int i;
+	int err;
+
+	for (i = 0; i < ARRAY_SIZE(ee_attrs); i++) {
+		err = device_create_file(&dev->dev, &ee_attrs[i].devattr);
+		if (err != 0) {
+			while (--i >= 0)
+				device_remove_file(&dev->dev,
+						&ee_attrs[i].devattr);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static void bone_capebus_sysfs_unregister(struct cape_dev *dev)
+{
+	int i;
+
+	i = ARRAY_SIZE(ee_attrs);
+	while (--i >= 0)
+		device_remove_file(&dev->dev, &ee_attrs[i].devattr);
+}
+
+static int bone_capebus_dev_probed(struct cape_dev *dev)
+{
+	int ret;
+
+	ret = bone_capebus_sysfs_register(dev);
+	if (ret != 0) {
+		dev_err(&dev->dev, "bone_capebus sysfs registration failed\n");
+		return ret;
+	}
+	return 0;
+}
+
+static void bone_capebus_dev_removed(struct cape_dev *dev)
+{
+	bone_capebus_sysfs_unregister(dev);
+}
+
+static struct cape_bus_ops bone_capebus_ops = {
+	.get_dev_id 		= bone_capebus_get_dev_id,
+	.get_text_dev_id	= bone_capebus_get_text_dev_id,
+	.dev_probed		= bone_capebus_dev_probed,
+	.dev_removed		= bone_capebus_dev_removed,
+};
+
+static int __devinit
+bone_capebus_probe(struct platform_device *pdev)
+{
+	struct bone_capebus_bus	*bus;
+	struct device_node	*pnode = pdev->dev.of_node;
+	const struct of_device_id *match;
+	struct bone_capebus_slot *slot;
+	const struct bone_capebus_eeprom_field *ee_field;
+	struct property *prop;
+	int length;
+	int r;
+	struct device_node *node;
+	struct i2c_client *client;
+	phandle handle;
+	u32 *slot_handles = NULL;
+	u32 val;
+	const char *str;
+	u8 *p;
+	int i, len;
+
+	/* we don't use platform_data */
+
+	bus = devm_kzalloc(&pdev->dev,
+			sizeof(struct bone_capebus_bus), GFP_KERNEL);
+	if (!bus) {
+		dev_err(&pdev->dev, "Failed to allocate device structure\n");
+		return -ENOMEM;
+	}
+
+	/* register the cape bus */
+	r = cape_bus_register(&bus->cape_bus, "bone", 0, &pdev->dev,
+			&bone_capebus_ops);
+	if (r != 0) {
+		dev_err(&pdev->dev, "Failed to register the cape device\n");
+		return r;
+	}
+
+	match = of_match_device(of_match_ptr(bone_capebus_of_match),
+			&pdev->dev);
+	if (!match) {
+		dev_err(&pdev->dev, "Failed to configure bone capebus\n");
+		return -ENODEV;
+	}
+	bus->dev = &pdev->dev;
+
+	prop = of_find_property(pnode, "slots", &length);
+	if (prop == NULL) {
+		dev_err(&pdev->dev, "Unable to find required "
+				"property 'slots'\n");
+		return -EINVAL;
+	}
+	bus->slots_nr = length / sizeof(u32);
+	bus->slots = devm_kzalloc(&pdev->dev,
+			sizeof(bus->slots[0]) * bus->slots_nr, GFP_KERNEL);
+	if (!bus->slots) {
+		dev_err(&pdev->dev, "Failed to allocate %d slot areas\n",
+				bus->slots_nr);
+		return -ENOMEM;
+	}
+	slot_handles = devm_kzalloc(&pdev->dev, length, GFP_KERNEL);
+	if (!slot_handles) {
+		dev_err(&pdev->dev, "Failed to allocate %d slot areas\n",
+				bus->slots_nr);
+		return -ENOMEM;
+	}
+	r = of_property_read_u32_array(pnode, "slots",
+			slot_handles, bus->slots_nr);
+	if (r < 0) {
+		dev_err(&pdev->dev, "Failed to read %d slot handles\n",
+				bus->slots_nr);
+		return r;
+	}
+
+	/* now we iterate over any overrides */
+	for_each_child_of_node(pnode, node) {
+
+		match = of_match_node(slot_override_of_match, node);
+		if (!match)
+			continue;
+
+		/* no reg property */
+		if (of_property_read_u32(node, "slot", &val) != 0) {
+			dev_warn(&pdev->dev, "override: Failed to read "
+					"slot property\n");
+			continue;
+		}
+
+		if (val >= bus->slots_nr) {
+			dev_warn(&pdev->dev, "override: invalid slot #%u\n",
+					val);
+			continue;
+		}
+
+		slot = &bus->slots[val];
+
+		if (slot->eeprom_override) {
+			dev_warn(&pdev->dev, "override: slot #%u is already "
+					"overriden\n", val);
+			continue;
+		}
+
+		slot->eeprom_override = 1;
+
+		/* copy template */
+		memcpy(slot->eeprom_signature, eeprom_signature_template,
+				sizeof(slot->eeprom_signature));
+
+		/* for any matching field assign them */
+		for (i = 0; i < ARRAY_SIZE(eeprom_fields); i++) {
+
+			ee_field = &eeprom_fields[i];
+
+			if (of_property_read_string(node, ee_field->name,
+						&str) != 0)
+				continue;
+
+			/* copy it to the eeprom signature buf */
+			p = slot->eeprom_signature + ee_field->start;
+			len = strlen(str);
+			if (len > ee_field->size)
+				len = ee_field->size;
+
+			/* copy and zero out rest */
+			memcpy(p, str, len);
+			if (len < ee_field->size)
+				memset(p + len, 0, ee_field->size - len);
+		}
+	}
+
+	platform_set_drvdata(pdev, bus);
+
+	/* now find the i2c clients */
+	for (i = 0; i < bus->slots_nr; i++) {
+
+		slot = &bus->slots[i];
+
+		handle = slot_handles[i];
+		node = of_find_node_by_phandle(handle);
+		if (node == NULL) {
+			dev_warn(&pdev->dev, "Failed to find node with phandle "
+					"0x%x (#%d)\n", handle, i);
+			continue;
+		}
+		dev_dbg(&pdev->dev, "Found device node for phandle "
+				"0x%x (#%d)\n", handle, i);
+
+		client = of_find_i2c_device_by_node(node);
+		if (client == NULL) {
+			dev_warn(&pdev->dev, "Invalid I2C client node with "
+					"phandle 0x%x (#%d)\n", handle, i);
+			continue;
+		}
+
+		slot->client = i2c_use_client(client);
+		/* no use for this anymore */
+		of_node_put(node);
+
+		/* save handle */
+		client = slot->client;	/* get again */
+		slot->eeprom_addr = client->addr;
+		dev_dbg(&pdev->dev, "Found i2c_client at #%d "
+				"(address = 0x%02x)\n",
+				i, slot->eeprom_addr);
+
+		r = cape_bus_register_slot(&bus->cape_bus, &slot->cape_slot, i);
+		if (r != 0) {
+			dev_err(&pdev->dev, "Failed to register slot #%d\n", i);
+			continue;
+		}
+
+		dev_info(&pdev->dev, "Registered slot #%d OK\n", i);
+	}
+
+	/* we don't need the handles anymore */
+	devm_kfree(&pdev->dev, slot_handles);
+	slot_handles = NULL;
+
+	pm_runtime_enable(bus->dev);
+	r = pm_runtime_get_sync(bus->dev);
+	if (IS_ERR_VALUE(r)) {
+		dev_err(&pdev->dev, "Failed to pm_runtime_get_sync()\n");
+		goto err_exit;
+	}
+
+	pm_runtime_put(bus->dev);
+
+	dev_info(&pdev->dev, "initialized OK.\n");
+
+	return 0;
+
+err_exit:
+	platform_set_drvdata(pdev, NULL);
+
+	return r;
+}
+
+static int __devexit bone_capebus_remove(struct platform_device *pdev)
+{
+	struct bone_capebus_bus	*dev = platform_get_drvdata(pdev);
+	int ret;
+
+	(void)dev;
+
+	platform_set_drvdata(pdev, NULL);
+
+	ret = pm_runtime_get_sync(&pdev->dev);
+	if (IS_ERR_VALUE(ret))
+		return ret;
+
+	pm_runtime_put(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+#ifdef CONFIG_PM_RUNTIME
+static int bone_capebus_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_capebus_bus *_dev = platform_get_drvdata(pdev);
+
+	(void)_dev;
+	return 0;
+}
+
+static int bone_capebus_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct bone_capebus_bus *_dev = platform_get_drvdata(pdev);
+
+	(void)_dev;
+	return 0;
+}
+#endif /* CONFIG_PM_RUNTIME */
+
+static struct dev_pm_ops bone_capebus_pm_ops = {
+	SET_RUNTIME_PM_OPS(bone_capebus_runtime_suspend,
+			   bone_capebus_runtime_resume, NULL)
+};
+#define BONE_CAPEBUS_PM_OPS (&bone_capebus_pm_ops)
+#else
+#define BONE_CAPEBUS_PM_OPS NULL
+#endif /* CONFIG_PM */
+
+static struct platform_driver bone_capebus_driver = {
+	.probe		= bone_capebus_probe,
+	.remove		= __devexit_p(bone_capebus_remove),
+	.driver		= {
+		.name	= "bone-capebus",
+		.owner	= THIS_MODULE,
+		.pm	= BONE_CAPEBUS_PM_OPS,
+		.of_match_table = of_match_ptr(bone_capebus_of_match),
+	},
+};
+
+module_platform_driver(bone_capebus_driver);
+
+MODULE_AUTHOR("Pantelis Antoniou");
+MODULE_DESCRIPTION("Beaglebone cape bus controller");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:capebus_bone");
diff --git a/include/linux/capebus/capebus-bone.h b/include/linux/capebus/capebus-bone.h
new file mode 100644
index 0000000..bc02558
--- /dev/null
+++ b/include/linux/capebus/capebus-bone.h
@@ -0,0 +1,86 @@
+/*
+ * capebus-bone.h
+ *
+ * Cape bus defines and function prototypes for the beaglebone
+ *
+ * Copyright (C) 2012 Pantelis Antoniou <panto@antoniou-consulting.com>
+ * Copyright (C) 2012 Texas Instruments Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#ifndef LINUX_CAPEBUS_BONE_H
+#define LINUX_CAPEBUS_BONE_H
+
+#include <linux/capebus.h>
+
+struct bone_capebus_slot {
+	struct cape_slot	cape_slot;
+	u32			slot_handle;
+	int			eeprom_addr;
+	struct i2c_client	*client;
+	unsigned int		eeprom_probed : 1;
+	unsigned int		eeprom_failed : 1;
+	unsigned int		eeprom_override : 1;
+	struct cape_device_id	id;
+	char			text_id[32 + 1];
+	char			eeprom_signature[256];
+};
+
+#define to_bone_capebus_slot(n)	\
+	container_of(n, struct bone_capebus_slot, cape_slot)
+
+struct bone_capebus_bus {
+	struct cape_bus			cape_bus;
+	struct device			*dev;		/* pdev->dev */
+	int 				slots_nr;
+	struct bone_capebus_slot	*slots;
+};
+
+#define to_bone_capebus_bus(n)	\
+	container_of(n, struct bone_capebus_bus, cape_bus)
+
+#define BONE_CAPEBUS_HEADER		0
+#define BONE_CAPEBUS_EEPROM_REV		1
+#define BONE_CAPEBUS_BOARD_NAME		2
+#define BONE_CAPEBUS_VERSION		3
+#define BONE_CAPEBUS_MANUFACTURER	4
+#define BONE_CAPEBUS_PART_NUMBER	5
+#define BONE_CAPEBUS_NUMBER_OF_PINS	6
+#define BONE_CAPEBUS_SERIAL_NUMBER	7
+#define BONE_CAPEBUS_PIN_USAGE		8
+#define BONE_CAPEBUS_VDD_3V3EXP		9
+#define BONE_CAPEBUS_VDD_5V		10
+#define BONE_CAPEBUS_SYS_5V		11
+#define BONE_CAPEBUS_DC_SUPPLIED	12
+#define BONE_CAPEBUS_FIELDS_NR		13
+
+#define BONE_CAPEBUS_MAKE_HEADER(p)	\
+	({ \
+		const u8 *_p = (p); \
+		(((u32)_p[0] << 24) | ((u32)_p[1] << 16) | \
+		((u32)_p[2] <<  8) |  (u32)_p[3]       ); \
+	})
+
+#define BONE_CAPEBUS_HEADER_VALID	0xaa5533ee
+
+char *bone_capebus_id_get_field(const struct cape_device_id *id,
+		int field, char *buf, int bufsz);
+
+int bone_capebus_match_cntrlboard(const struct cape_device_id *id);
+
+int bone_capebus_match_board(const struct cape_device_id *id,
+		const char **board_names);
+
+#endif
-- 
1.7.7.6

