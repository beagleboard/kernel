From 30efe8dbe814e195faaa3a2b686693ae9c75ead0 Mon Sep 17 00:00:00 2001
From: "Philip, Avinash" <avinashphilip@ti.com>
Date: Thu, 9 Aug 2012 13:52:37 +0530
Subject: [PATCH 05/13] pwm: pwm-tiehrpwm: Add support for configuring
 polarity of PWM

EHRPWM hardware supports polarity configuration of PWM output.
This commit adds support for polarity configuration for EHRPWM.
When being here, remove configuring of polarity during .config() and do
it explicitly from .set_polarity().

Signed-off-by: Philip, Avinash <avinashphilip@ti.com>
---
 drivers/pwm/pwm-tiehrpwm.c |  107 +++++++++++++++++++++++++++++++------------
 1 files changed, 77 insertions(+), 30 deletions(-)

diff --git a/drivers/pwm/pwm-tiehrpwm.c b/drivers/pwm/pwm-tiehrpwm.c
index c3756d1..2d1bff5 100644
--- a/drivers/pwm/pwm-tiehrpwm.c
+++ b/drivers/pwm/pwm-tiehrpwm.c
@@ -100,10 +100,17 @@
 
 #define NUM_PWM_CHANNEL		2	/* EHRPWM channels */
 
+enum config {
+	config_dutycycle,
+	config_polarity,
+};
+
 struct ehrpwm_pwm_chip {
 	struct pwm_chip	chip;
 	unsigned int	clk_rate;
 	void __iomem	*mmio_base;
+	unsigned long duty_cycles;
+	enum pwm_polarity polarity;
 };
 
 static inline struct ehrpwm_pwm_chip *to_ehrpwm_pwm_chip(struct pwm_chip *chip)
@@ -165,38 +172,60 @@ static int set_prescale_div(unsigned long rqst_prescaler,
 }
 
 static void configure_chans(struct ehrpwm_pwm_chip *pc, int chan,
-		unsigned long duty_cycles)
+		enum config config)
 {
-	int cmp_reg, aqctl_reg;
-	unsigned short aqctl_val, aqctl_mask;
+	if (config == config_dutycycle) {
+		int cmp_reg;
+
+		if (chan == 1)
+			cmp_reg = CMPB;
+		else
+			cmp_reg = CMPA;
+
+		ehrpwm_write(pc->mmio_base,  cmp_reg, pc->duty_cycles);
+	} else if (config == config_polarity) {
+		int aqctl_reg;
+		unsigned short aqctl_val, aqctl_mask;
+
+		/*
+		 * Channels polarity can be configured from action qualifier
+		 * module
+		 */
+		if (chan == 1) {
+			aqctl_reg = AQCTLB;
+			aqctl_mask = AQCTL_CBU_MASK;
+			/*
+			 * Configure PWM output to HIGH/LOW level on counter
+			 * reaches compare B register value & LOW/HIGH level
+			 * on counter value reaches period register value
+			 * and zero value on counter
+			 */
+			if (pc->polarity == PWM_POLARITY_INVERSED)
+				aqctl_val = AQCTL_CBU_FRCHIGH |
+					AQCTL_PRD_FRCLOW | AQCTL_ZRO_FRCLOW;
+			else
+				aqctl_val = AQCTL_CBU_FRCLOW |
+					AQCTL_PRD_FRCHIGH | AQCTL_ZRO_FRCHIGH;
+		} else {
+			aqctl_reg = AQCTLA;
+			aqctl_mask = AQCTL_CAU_MASK;
+			/*
+			 * Configure PWM output to HIGH/LOW level on counter
+			 * reaches compare A register value & LOW/HIGH level on
+			 * counter value reaches period register value and zero
+			 * value on counter
+			 */
+			if (pc->polarity == PWM_POLARITY_INVERSED)
+				aqctl_val = AQCTL_CAU_FRCHIGH |
+					AQCTL_PRD_FRCLOW | AQCTL_ZRO_FRCLOW;
+			else
+				aqctl_val = AQCTL_CAU_FRCLOW |
+					AQCTL_PRD_FRCHIGH | AQCTL_ZRO_FRCHIGH;
+		}
 
-	/*
-	 * Channels can be configured from action qualifier module.
-	 * Channel 0 configured with compare A register and for
-	 * up-counter mode.
-	 * Channel 1 configured with compare B register and for
-	 * up-counter mode.
-	 */
-	if (chan == 1) {
-		aqctl_reg = AQCTLB;
-		cmp_reg = CMPB;
-		/* Configure PWM Low from compare B value */
-		aqctl_val = AQCTL_CBU_FRCLOW;
-		aqctl_mask = AQCTL_CBU_MASK;
-	} else {
-		cmp_reg = CMPA;
-		aqctl_reg = AQCTLA;
-		/* Configure PWM Low from compare A value*/
-		aqctl_val = AQCTL_CAU_FRCLOW;
-		aqctl_mask = AQCTL_CAU_MASK;
+		aqctl_mask |= AQCTL_PRD_MASK | AQCTL_ZRO_MASK;
+		ehrpwm_modify(pc->mmio_base,  aqctl_reg, aqctl_mask, aqctl_val);
 	}
-
-	/* Configure PWM High from period value and zero value */
-	aqctl_val |= AQCTL_PRD_FRCHIGH | AQCTL_ZRO_FRCHIGH;
-	aqctl_mask |= AQCTL_PRD_MASK | AQCTL_ZRO_MASK;
-	ehrpwm_modify(pc->mmio_base,  aqctl_reg, aqctl_mask, aqctl_val);
-
-	ehrpwm_write(pc->mmio_base,  cmp_reg, duty_cycles);
 }
 
 /*
@@ -254,12 +283,29 @@ static int ehrpwm_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,
 	ehrpwm_modify(pc->mmio_base, TBCTL, TBCTL_CTRMODE_MASK,
 			TBCTL_CTRMODE_UP);
 
+	pc->duty_cycles = duty_cycles;
 	/* Configure the channel for duty cycle */
-	configure_chans(pc, pwm->hwpwm, duty_cycles);
+	configure_chans(pc, pwm->hwpwm, config_dutycycle);
+
 	pm_runtime_put_sync(chip->dev);
 	return 0;
 }
 
+static int ehrpwm_pwm_set_polarity(struct pwm_chip *chip,
+		struct pwm_device *pwm,	enum pwm_polarity polarity)
+{
+	struct ehrpwm_pwm_chip *pc = to_ehrpwm_pwm_chip(chip);
+
+	pm_runtime_get_sync(pc->chip.dev);
+
+	pc->polarity = polarity;
+	/* Channels Polarity can be configured from action qualifier module */
+	configure_chans(pc, pwm->hwpwm, config_polarity);
+
+	pm_runtime_put_sync(pc->chip.dev);
+	return 0;
+}
+
 static int ehrpwm_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)
 {
 	struct ehrpwm_pwm_chip *pc = to_ehrpwm_pwm_chip(chip);
@@ -329,6 +375,7 @@ static void ehrpwm_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)
 static const struct pwm_ops ehrpwm_pwm_ops = {
 	.free		= ehrpwm_pwm_free,
 	.config		= ehrpwm_pwm_config,
+	.set_polarity	= ehrpwm_pwm_set_polarity,
 	.enable		= ehrpwm_pwm_enable,
 	.disable	= ehrpwm_pwm_disable,
 	.owner		= THIS_MODULE,
-- 
1.7.7.6

